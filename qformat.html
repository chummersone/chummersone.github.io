<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="description" content="Convert between floating-point values and their Qm.n fixed-point integer representations, and calculate the representation error.">
        <meta name="keywords" content="q-fomat, fixed-point, floating-point, convert, calculate">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Q-format Converter</title>
        <meta property="og:title" content="Q-format Converter" />
        <meta property="og:url" content="https://chummersone.github.io/qformat.html" />
        <meta property="og:locale" content="en_GB" />
        <meta property="og:description" content="Convert between floating-point and Qm.n fixed-point values">
        <meta property="og:site_name" content="chummersone.github.io" />
        <meta property="og:type" content="website" />
        <link rel="stylesheet" href="https://chummersone.github.io/assets/css/style.css?v=f6040d589f1187e6eaa1ec97f2b3af33299fb0ad">
        <style>
            html {
                padding: 10px;
                box-sizing: border-box;
                font-family: sans-serif;
                font-size: 16px;
            }

            body {
                font: inherit;
            }

            h1 {
                margin: 20px 0;
                font-size: 2em;
            }

            p {
                margin: 15px 0;
                text-align: left;
            }

            fieldset {
                max-width: 420px;
                width: 100%;
                display: inline-block;
                vertical-align: top;
                margin: 2px;
                border-radius: 5px;
                background-color: #f2f2f2;
                padding: 20px;
            }

            fieldset.full-width {
                max-width: 846px;
            }

            legend {
                font-weight: bold;
            }

            div#container {
                display: flex;
                justify-content: center;
                flex-wrap: wrap;
            }

            input[type=text] {
                text-overflow: ellipsis;
            }

            input {
                text-align: right;
            }

            input[type=text].error,
            input[type=number].error,
            select.error,
            textarea.error {
                border-color: darkred;
                background-color: #da8383;
            }

            div.error {
                display: block;
                font-size: smaller;
                color: darkred;
            }
            
            input[type=text], input[type=number], select, textarea {
                width: 100%;
                padding: 12px;
                border: 1px solid #ccc;
                border-radius: 4px;
                box-sizing: border-box;
                resize: vertical;
                background-color: white;
            }

            input:disabled {
                background-color: #ccc;
                -webkit-text-fill-color: #444;
                opacity: 1; /* required on iOS */
            }

            /* Style the label to display next to the inputs */
            label {
                display: inline-block;
                padding-right: 5px;
                text-align: center;
                width: 100%;
            }

            label::after {
                content: ':';
            }

            .col {
                margin-top: 6px;
                display: inline-block;
                text-align: center;
            }

            /* Floating column for labels: 25% width */
            .col.w25 {
                width: 30%;
            }

            /* Floating column for inputs: 75% width */
            .col.w75 {
                width: 70%;
            }

            .control-grp {
                margin: 5px 0;
            }

            /* Clear floats after the columns */
            .control-grp::after {
                content: "";
                display: table;
                clear: both;
            }

            .control-grp .col {
                vertical-align: middle;
            }

            input#integer, input#float {
                font-family: monospace;
            }

            table {
                border-collapse: collapse;
                margin: 0 auto;
            }

            td, th {
                border: 1px solid #999;
                padding: 5px;
                text-align: right;
            }

            /* Responsive layout - when the screen is less than 600px wide, make the two columns stack on top of each other instead of next to each other */
            @media screen and (max-width: 444px) {
                .col.w25, .col.w75 {
                    width: 100%;
                    margin-top: 0;
                }
            }
        </style>
        <script src="https://code.jquery.com/jquery-3.6.0.min.js"
                integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4="
                crossorigin="anonymous">
        </script>
        <script>
            $(function() {

                const numBitsID = '#num_bits';
                const numFracBitsID = '#num_frac_bits';
                const signedID = '#signed';
                const formatID = '#format';
                const integerID = '#integer';
                const floatID = '#float';
                const realFloatID = '#realfloat';
                const floatErrorID = '#floaterror';
                const errorDbID = '#errordb';
                const labelFormatID = '#labelformat';

                /**
                 * Recalculate the integer of float value, according to what was last modified.
                 */
                function recalculate() {
                    if (userChangedFloat) {
                        calculateIntegerValue();
                    } else {
                        calculateFloatValue();
                    }
                }

                /**
                 * Calculate the maximum float value for the current Q-format.
                 * @returns The maximum float value.
                 */
                function maxfloat() {
                    var signCorrection = 0;
                    if (currentSigned) {
                        signCorrection = 1;
                    }
                    return (2 ** (currentNumBits - currentNumFracBits - signCorrection)) - (2 ** -currentNumFracBits);
                }

                /**
                 * Calculate the minimum float value for the current Q-format.
                 * @returns The minimum float value.
                 */
                function minfloat() {
                    var signCorrection = 0;
                    if (currentSigned) {
                        return - (2 ** (currentNumBits - currentNumFracBits - 1));
                    } else {
                        return 0;
                    }
                }

                /**
                 * Calculate the maximum integer value for the current Q-format.
                 * @returns The maximum integer value.
                 */
                function maxinteger() {
                    var signCorrection = 0;
                    if (currentSigned) {
                        signCorrection = 1;
                    }
                    return (2 ** (currentNumBits - signCorrection)) - 1;
                }

                /**
                 * Calculate the minimum integer value for the current Q-format.
                 * @returns The minimum integer value.
                 */
                function mininteger() {
                    var signCorrection = 0;
                    if (currentSigned) {
                        return - (2 ** (currentNumBits - 1));
                    } else {
                        return 0;
                    }
                }

                /**
                 * Calculate a bit mask for the current word.
                 * @returns The bit mask.
                 */
                function wordmask() {
                    if (currentNumBits < 32) {
                        return ((1 << currentNumBits) - 1);
                    } else {
                        return 0xFFFFFFFF;
                    }
                }

                /**
                 * Get the word size, in bits, from the DOM form.
                 * @returns The word size in bits.
                 */
                function getFormNumBits() {
                    return parseInt($(numBitsID + ' option:selected').val());
                }

                /**
                 * Set the number of bits. This function updates the UI, decrements the number of
                 * fractional bits, if necessary, and updates other form control attributes and
                 * values.
                 * @param {number} val If provided, the new number of bits. Otherwise use the
                 * value in the form.
                 * @param {bool} calculate Calculate the integer or float value?
                 */
                function setFormNumBits(val, calculate = true) {
                    if (!(val == null)) {
                        $(numBitsID + ' option:selected').val(val.toString());
                    } else {
                        val = getFormNumBits();
                    }
                    if (val < currentNumFracBits) {
                        var newNumFracBits = currentNumFracBits - (currentNumBits - val);
                        setFormNumFracBits(newNumFracBits);
                    }
                    currentNumBits = val;
                    $(numFracBitsID).attr('max', val);
                    setFormFormat(currentFormat);
                    updateMinMax();
                    updateBitPositionsTable();
                    if (calculate) {
                        recalculate();
                    }
                }

                /**
                 * Get the number of fractional bits from the DOM.
                 * @returns The number of fractional bits.
                 */
                function getFormNumFracBits() {
                    return parseInt($(numFracBitsID).val());
                }

                /**
                 * Set the number of fractional bits. This function updates the UI, and
                 * updates other form controls.
                 * @param {number} val If provided, the new number of bits. Otherwise use the
                 * value in the form.
                 * @param {bool} calculate Calculate the integer or float value?
                 */
                function setFormNumFracBits(val, calculate = true) {
                    if (!(val == null)) {
                        $(numFracBitsID).val(val.toString());
                    } else {
                        val = getFormNumFracBits();
                    }
                    currentNumFracBits = val;
                    updateMinMax();
                    updateBitPositionsTable();
                    if (calculate) {
                        recalculate();
                    }
                }

                /**
                 * Determine whether values are signed.
                 * @returns Returns true if values are signed, otherwise false.
                 */
                function getFormSigned() {
                    return $(signedID).prop('checked');
                }

                /**
                 * Update the signed-ness of the calculations, and optionally update the UI.
                 * @param {bool} val If provided, whether the values are signed. Otherwise use
                 * the value in the form.
                 * @param {bool} calculate Calculate the integer or float value?
                 */
                function setFormSigned(val, calculate = true) {
                    if (!(val == null)) {
                        $(signedID).prop('checked', val);
                    } else {
                        val = getFormSigned();
                    }
                    currentSigned = val;
                    updateMinMax();
                    updateBitPositionsTable();
                    if (calculate) {
                        recalculate();
                    }
                }

                /**
                 * Get the integer display format from the DOM.
                 * @returns The float value.
                 */
                function getFormFormat() {
                    return $(formatID + ' option:selected').val();
                }

                /**
                 * Set the form integer display format. Update the form attributes and the UI.
                 * @param {string} val The format.
                 */
                function setFormFormat(val) {
                    if (!(val == null)) {
                        $(formatID).val(val);
                    } else {
                        val = getFormFormat();
                    }
                    var maxlength = 0;
                    var floatlabel = '';
                    switch (val) {
                        case 'hex':
                            maxlength = Math.ceil(currentNumBits / 4);
                            floatlabel = 'hexadecimal';
                            break;
                        case 'bin':
                            maxlength = currentNumBits;
                            floatlabel = 'binary';
                            break;
                        default:
                            maxlength = (2 ** currentNumBits).toString().length + 1;
                            floatlabel = 'decimal';
                    }
                    $(labelFormatID).text(floatlabel);
                    $(integerID).attr('maxlength', maxlength.toString());
                    currentFormat = val;
                    setFormInteger(currentInteger, false);
                }

                /**
                 * Get the integer value from the DOM.
                 * @returns The integer value.
                 */
                function getFormInteger() {
                    var intstr = $(integerID).val().toLowerCase();
                    clearError(integerID);
                    $('div.error').remove();
                    if (intstr.startsWith('0b')) {
                        setFormFormat('bin');
                        intstr = intstr.substring(2);
                    } else if (intstr.startsWith('0x')) {
                        setFormFormat('hex');
                        intstr = intstr.substring(2);
                    }
                    var base = 0;
                    switch (currentFormat) {
                        case 'hex':
                            base = 16;
                            break;
                        case 'bin':
                            base = 2;
                            break;
                        default:
                            base = 10;
                    }
                    var intval = parseInt(intstr, base);
                    if (isNaN(intval)) {
                        setError(integerID);
                    } else {
                        clearError(integerID);
                        if (currentSigned && ((0x1 << (currentNumBits - 1)) & intval)) {
                            /* insert missing redundant sign bits for 32-bit internal representation */
                            intval = (intval | (~wordmask()));
                        }
                    }
                    return intval;
                }

                /**
                 * Update the integer displayed in the DOM.
                 * @param {number} val If provided, use this value as the new integer.
                 * Otherwise use the value in the form.
                 * @param {bool} calculate 
                 */
                function setFormInteger(val, calculate = true) {
                    if (val == null) {
                        val = getFormInteger();
                    }
                    currentInteger = val;
                    var pad = parseInt($(integerID).attr('maxlength'));
                    if (!isNaN(val)) {
                        switch (currentFormat) {
                            case 'hex':
                            case 'bin':
                                /* mask out-of-range bits */
                                val = val & wordmask();
                                /* force to unsigned to prevent a negative symbol */
                                val = val >>> 0;
                                break;
                        }
                        var intstr = '';
                        switch (currentFormat) {
                            case 'hex':
                                intstr = val.toString(16).padStart(pad, '0');
                                break;
                            case 'bin':
                                intstr = val.toString(2).padStart(pad, '0');
                                break;
                            default:
                                intstr = val.toString();
                        }
                        $(integerID).val(intstr);
                        realFloatVal = currentInteger / (2 ** currentNumFracBits);
                        $(realFloatID).val(realFloatVal.toString());
                        var floatErr = Math.abs(realFloatVal - currentFloat);
                        $(floatErrorID).val(floatErr.toString());
                        $(errorDbID).val(20*Math.log10(floatErr).toFixed(3));
                    }
                    if (calculate) {
                        recalculate();
                    }
                }

                /**
                 * Get the float value from the DOM.
                 * @returns The float value.
                 */
                function getFormFloat() {
                    clearError(floatID);
                    $('div.error').remove();
                    var floatval = parseFloat($(floatID).val());
                    if (isNaN(floatval)) {
                        setError(floatID);
                    } else {
                        clearError(floatID);
                    }
                    return floatval;
                }

                /**
                 * Update the float displayed in the DOM.
                 * @param {number} val If provided, use this value as the new float.
                 * Otherwise use the value in the form.
                 * @param {bool} calculate 
                 */
                function setFormFloat(val, calculate = true) {
                    if (!(val == null)) {
                        $(floatID).val(val.toString());
                    } else {
                        val = getFormFloat();
                    }
                    currentFloat = val;
                    setFormInteger(currentInteger, false);
                    if (calculate) {
                        recalculate();
                    }
                }

                var currentNumBits = getFormNumBits();
                var currentNumFracBits = getFormNumFracBits();
                var currentSigned = getFormSigned();
                var currentFormat = getFormFormat();
                var currentInteger = getFormInteger();
                var currentFloat = getFormFloat();
                var realFloatVal = currentFloat;
                var userChangedFloat = false;

                $(numBitsID).change(function () {
                    setFormNumBits();
                });

                $(numFracBitsID).change(function () {
                    setFormNumFracBits();
                });

                $(signedID).change(function () {
                    setFormSigned();
                });

                $(formatID).change(function () {
                    setFormFormat();
                });

                $(integerID).change(function () {
                    userChangedFloat = false;
                    setFormInteger();
                });

                $(floatID).change(function () {
                    userChangedFloat = true;
                    setFormFloat();
                });

                /**
                 * Set an error on the form element.
                 */
                function setError(elem) {
                    $(elem).addClass('error');
                    $(realFloatID).val('');
                    $(floatErrorID).val('');
                }

                /**
                 * Clear the error on the form element.
                 */
                function clearError(elem) {
                    $(elem).removeClass('error');
                }

                /**
                 * Calculate the new floating-point value.
                 */
                function calculateFloatValue() {
                    if (!isNaN(currentInteger)) {
                        clearError(integerID);
                        $('div.error').remove();
                        if (currentInteger > maxinteger() || currentInteger < mininteger()) {
                            setError(integerID);
                            $(integerID).after($('<div class="error">Out of range</div>'));
                        } else {
                            var newFloat = currentInteger / (2 ** currentNumFracBits);
                            setFormFloat(newFloat, false);
                        }
                    } else {
                        setError(integerID);
                    }
                }

                /**
                 * Calculate the new integer value.
                 */
                function calculateIntegerValue() {
                    if (!isNaN(currentFloat)) {
                        clearError(floatID);
                        if (currentFloat > maxfloat() || currentFloat < minfloat()) {
                            setError(floatID);
                            $('div.error').remove();
                            $(floatID).after($('<div class="error">Out of range</div>'));
                        } else {
                            var newInt = Math.round(currentFloat * (2 ** currentNumFracBits));
                            setFormInteger(newInt, false);
                        }
                    } else {
                        setError(floatID);
                    }
                }

                /**
                 * Update the displayed min and max float values.
                 */
                function updateMinMax() {
                    $('input#maxfloat').val(maxfloat().toString());
                    $('input#minfloat').val(minfloat().toString());
                }

                /**
                 * Update the bit positions table.
                 */
                function updateBitPositionsTable() {
                    var $bitPosSelection = $('table#bit-pos tr#bit-positions td');
                    var midwayPos = Math.floor($bitPosSelection.length / 2);
                    $('table#bit-pos tr#bit-positions td').each(function (index) {
                        if (index >= 0 && index < midwayPos) {
                            $(this).text((currentNumBits - index - 1).toString());
                        }
                    });

                    var $bitValuesSelection = $('table#bit-pos tr#bit-values td');
                    var midwayValues = Math.floor($bitValuesSelection.length / 2);
                    $bitValuesSelection.each(function (index) {
                        var bitPosition = 0;
                        if (index >= 0 && index < midwayValues) {
                            bitPosition = currentNumBits - index - 1;
                        } else {
                            bitPosition = currentNumBits - index - 1 - (currentNumBits - $bitValuesSelection.length);
                        }
                        power = (bitPosition - currentNumFracBits).toString();
                        if (index != midwayValues) {
                            var content = "2<sup>" + power + "</sup>";
                            if (index == 0 && currentSigned) {
                                content = "&minus;" + content;
                            }
                            $(this).html(content);
                        }
                    });
                }

                recalculate();
                updateMinMax();
                updateBitPositionsTable();

            });
        </script>
    </head>

    <body>
        <h1>Q-format Converter</h1>

        <p>
            Convert between floating-point values and their <em>Qm.n</em> fixed-point integer representations, and calculate the representation error.
        </p>

        <div id="container">

            <fieldset>
                <legend>Q-Format Settings</legend>

                <p>Choose your conversion options.</p>

                <div class="control-grp">
                    <div class="col w25">
                        <label for="num_bits">Word size in bits (<em>m+n</em>)</label>
                    </div><!--
                    ---><div class="col w75">
                        <select id="num_bits">
                            <option value="16">16</option>
                            <option value="24" selected>24</option>
                            <option value="32">32</option>
                        </select>
                    </div>
                </div>

                <div class="control-grp">
                    <div class="col w25">
                        <label for="num_frac_bits">Fractional bits (<em>n</em>)</label>
                    </div><!--
                ---><div class="col w75">
                        <input id="num_frac_bits" type="number" value="23" min="0" max="24">
                    </div>
                </div>

                <div class="control-grp">
                    <div class="col w25">
                        <label for="signed">Signed?</label>
                    </div><!--
                    ---><div class="col w75">
                        <input id="signed" type="checkbox" checked>
                    </div>
                </div>

                <div class="control-grp">
                    <div class="col w25">
                        <label for="format">Integer format</label>
                    </div><!--
                    ---><div class="col w75">
                        <select id="format">
                            <option value="hex" selected>Hexadecimal</option>
                            <option value="dec">Decimal</option>
                            <option value="bin">Binary</option>
                        </select>
                    </div>
                </div>

                <div class="control-grp">
                    <div class="col w25">
                        <label for="maxfloat">Maximum float value</label>
                    </div><!--
                    ---><div class="col w75">
                        <input id="maxfloat" type="text" value="0" disabled>
                    </div>
                </div>

                <div class="control-grp">
                    <div class="col w25">
                        <label for="minfloat">Minimum float value</label>
                    </div><!--
                    ---><div class="col w75">
                        <input id="minfloat" type="text" value="0" disabled>
                    </div>
                </div>
            </fieldset><!--

        ---><fieldset>
                <legend>Convert</legend>

                <p>Type an integer or float in the boxes below. Click or tab away to update.</p>

                <div class="control-grp">
                    <div class="col w25">
                        <label for="integer">Integer (<span id="labelformat">hexadecimal</span>)</label>
                    </div><!--
                    ---><div class="col w75">
                        <input id="integer" type="text" value="0" maxlength="6">
                    </div>
                </div>

                <div class="control-grp">
                    <div class="col w25">
                        <label for="float">Float</label>
                    </div><!--
                    ---><div class="col w75">
                        <input id="float" type="text" value="0">
                    </div>
                </div>

                <div class="control-grp">
                    <div class="col w25">
                        <label for="realfloat">Fixed-point value</label>
                    </div><!--
                    ---><div class="col w75">
                        <input id="realfloat" type="text" value="0" disabled>
                    </div>
                </div>

                <div class="control-grp">
                    <div class="col w25">
                        <label for="floaterror">Representation error</label>
                    </div><!--
                    ---><div class="col w75">
                        <input id="floaterror" type="text" value="0" disabled>
                    </div>
                </div>

                <div class="control-grp">
                    <div class="col w25">
                        <label for="errordb">Representation error (dB)</label>
                    </div><!--
                    ---><div class="col w75">
                        <input id="errordb" type="text" value="0" disabled>
                    </div>
                </div>
            </fieldset><!--

        ---><fieldset class="full-width">
                <legend>Bit Positions</legend>

                <table id="bit-pos">
                    <tr id="bit-positions">
                        <th>Bit Position</th>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td>&hellip;</td>
                        <td>2</td>
                        <td>1</td>
                        <td>0</td>
                    </tr>
                    <tr id="bit-values">
                        <th>Bit Value</th>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td>&hellip;</td>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr>
                </table>
            
            </fieldset>

        </div>

    </body>

</html>
